/* gir_test_suite.c generated by valac 0.24.0, the Vala compiler
 * generated from gir_test_suite.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <girepository.h>


#define TYPE_TEST (test_get_type ())
#define TEST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TEST, Test))
#define TEST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TEST, TestClass))
#define IS_TEST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TEST))
#define IS_TEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TEST))
#define TEST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TEST, TestClass))

typedef struct _Test Test;
typedef struct _TestClass TestClass;
typedef struct _TestPrivate TestPrivate;

#define TYPE_GIR_VISITABLE (gir_visitable_get_type ())
#define GIR_VISITABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GIR_VISITABLE, GirVisitable))
#define IS_GIR_VISITABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GIR_VISITABLE))
#define GIR_VISITABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_GIR_VISITABLE, GirVisitableIface))

typedef struct _GirVisitable GirVisitable;
typedef struct _GirVisitableIface GirVisitableIface;

#define TYPE_GIR_VISITOR (gir_visitor_get_type ())
#define GIR_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GIR_VISITOR, GirVisitor))
#define IS_GIR_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GIR_VISITOR))
#define GIR_VISITOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_GIR_VISITOR, GirVisitorIface))

typedef struct _GirVisitor GirVisitor;
typedef struct _GirVisitorIface GirVisitorIface;

#define TYPE_BASE_INFO (base_info_get_type ())
#define BASE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BASE_INFO, BaseInfo))
#define IS_BASE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BASE_INFO))
#define BASE_INFO_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_BASE_INFO, BaseInfoIface))

typedef struct _BaseInfo BaseInfo;
typedef struct _BaseInfoIface BaseInfoIface;

#define TYPE_NAMESPACE (namespace_get_type ())
#define NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NAMESPACE, Namespace))
#define IS_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NAMESPACE))
#define NAMESPACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_NAMESPACE, NamespaceIface))

typedef struct _Namespace Namespace;
typedef struct _NamespaceIface NamespaceIface;

#define TYPE_GIR_DEBUG_VISITOR (gir_debug_visitor_get_type ())
#define GIR_DEBUG_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GIR_DEBUG_VISITOR, GirDebugVisitor))
#define GIR_DEBUG_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GIR_DEBUG_VISITOR, GirDebugVisitorClass))
#define IS_GIR_DEBUG_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GIR_DEBUG_VISITOR))
#define IS_GIR_DEBUG_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GIR_DEBUG_VISITOR))
#define GIR_DEBUG_VISITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GIR_DEBUG_VISITOR, GirDebugVisitorClass))

typedef struct _GirDebugVisitor GirDebugVisitor;
typedef struct _GirDebugVisitorClass GirDebugVisitorClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _GirDebugVisitorPrivate GirDebugVisitorPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_base_info_unref0(var) ((var == NULL) ? NULL : (var = (g_base_info_unref (var), NULL)))

#define TYPE_NAMESPACE_IMPL (namespace_impl_get_type ())
#define NAMESPACE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_NAMESPACE_IMPL, NamespaceImpl))
#define NAMESPACE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_NAMESPACE_IMPL, NamespaceImplClass))
#define IS_NAMESPACE_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_NAMESPACE_IMPL))
#define IS_NAMESPACE_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_NAMESPACE_IMPL))
#define NAMESPACE_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_NAMESPACE_IMPL, NamespaceImplClass))

typedef struct _NamespaceImpl NamespaceImpl;
typedef struct _NamespaceImplClass NamespaceImplClass;
typedef struct _NamespaceImplPrivate NamespaceImplPrivate;

#define TYPE_BASE_INFO_IMPL (base_info_impl_get_type ())
#define BASE_INFO_IMPL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BASE_INFO_IMPL, BaseInfoImpl))
#define BASE_INFO_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BASE_INFO_IMPL, BaseInfoImplClass))
#define IS_BASE_INFO_IMPL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BASE_INFO_IMPL))
#define IS_BASE_INFO_IMPL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BASE_INFO_IMPL))
#define BASE_INFO_IMPL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BASE_INFO_IMPL, BaseInfoImplClass))

typedef struct _BaseInfoImpl BaseInfoImpl;
typedef struct _BaseInfoImplClass BaseInfoImplClass;
typedef struct _BaseInfoImplPrivate BaseInfoImplPrivate;

struct _Test {
	GObject parent_instance;
	TestPrivate * priv;
};

struct _TestClass {
	GObjectClass parent_class;
};

struct _BaseInfoIface {
	GTypeInterface parent_iface;
	GIBaseInfo* (*get_base_info) (BaseInfo* self);
};

struct _GirVisitorIface {
	GTypeInterface parent_iface;
	void (*visit_namespace) (GirVisitor* self, Namespace* e);
	void (*visit_base_info) (GirVisitor* self, BaseInfo* e);
};

struct _GirVisitableIface {
	GTypeInterface parent_iface;
	void (*accept) (GirVisitable* self, GirVisitor* visitor);
};

struct _NamespaceIface {
	GTypeInterface parent_iface;
	GIRepository* (*get_repository) (Namespace* self);
	gchar* (*get_namespace) (Namespace* self);
};

struct _GirDebugVisitor {
	GObject parent_instance;
	GirDebugVisitorPrivate * priv;
};

struct _GirDebugVisitorClass {
	GObjectClass parent_class;
	void (*visit_namespace) (GirDebugVisitor* self, Namespace* e);
	void (*visit_base_info) (GirDebugVisitor* self, BaseInfo* e);
};

struct _NamespaceImpl {
	GObject parent_instance;
	NamespaceImplPrivate * priv;
};

struct _NamespaceImplClass {
	GObjectClass parent_class;
	GIRepository* (*get_repository) (NamespaceImpl* self);
	gchar* (*get_namespace) (NamespaceImpl* self);
	void (*accept) (NamespaceImpl* self, GirVisitor* visitor);
};

struct _NamespaceImplPrivate {
	GIRepository* _repository;
	gchar* _namespace;
};

struct _BaseInfoImpl {
	GObject parent_instance;
	BaseInfoImplPrivate * priv;
};

struct _BaseInfoImplClass {
	GObjectClass parent_class;
	GIBaseInfo* (*get_base_info) (BaseInfoImpl* self);
	void (*accept) (BaseInfoImpl* self, GirVisitor* visitor);
};

struct _BaseInfoImplPrivate {
	GIBaseInfo* _base_info;
};


static gpointer test_parent_class = NULL;
static gpointer gir_debug_visitor_parent_class = NULL;
static GirVisitorIface* gir_debug_visitor_gir_visitor_parent_iface = NULL;
static gpointer namespace_impl_parent_class = NULL;
static GirVisitableIface* namespace_impl_gir_visitable_parent_iface = NULL;
static NamespaceIface* namespace_impl_namespace_parent_iface = NULL;
static gpointer base_info_impl_parent_class = NULL;
static GirVisitableIface* base_info_impl_gir_visitable_parent_iface = NULL;
static BaseInfoIface* base_info_impl_base_info_parent_iface = NULL;

GType test_get_type (void) G_GNUC_CONST;
enum  {
	TEST_DUMMY_PROPERTY
};
gint test_main (gchar** args, int args_length1);
GType base_info_get_type (void) G_GNUC_CONST;
GType gir_visitor_get_type (void) G_GNUC_CONST;
GType gir_visitable_get_type (void) G_GNUC_CONST;
GType namespace_get_type (void) G_GNUC_CONST;
Namespace* namespace_new (GIRepository* repository, const gchar* namespace, GError** error);
GType gir_debug_visitor_get_type (void) G_GNUC_CONST;
GirDebugVisitor* gir_debug_visitor_new (void);
GirDebugVisitor* gir_debug_visitor_construct (GType object_type);
void gir_visitable_accept (GirVisitable* self, GirVisitor* visitor);
Test* test_new (void);
Test* test_construct (GType object_type);
void gir_visitor_visit_namespace (GirVisitor* self, Namespace* e);
void gir_visitor_visit_base_info (GirVisitor* self, BaseInfo* e);
enum  {
	GIR_DEBUG_VISITOR_DUMMY_PROPERTY
};
void gir_debug_visitor_visit_namespace (GirDebugVisitor* self, Namespace* e);
static void gir_debug_visitor_real_visit_namespace (GirDebugVisitor* self, Namespace* e);
gchar* namespace_get_namespace (Namespace* self);
void gir_debug_visitor_visit_base_info (GirDebugVisitor* self, BaseInfo* e);
static void gir_debug_visitor_real_visit_base_info (GirDebugVisitor* self, BaseInfo* e);
GIBaseInfo* base_info_get_base_info (BaseInfo* self);
GIRepository* namespace_get_repository (Namespace* self);
GType namespace_impl_get_type (void) G_GNUC_CONST;
NamespaceImpl* namespace_impl_new (GIRepository* repository, const gchar* namespace, GError** error);
NamespaceImpl* namespace_impl_construct (GType object_type, GIRepository* repository, const gchar* namespace, GError** error);
#define NAMESPACE_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_NAMESPACE_IMPL, NamespaceImplPrivate))
enum  {
	NAMESPACE_IMPL_DUMMY_PROPERTY
};
GIRepository* namespace_impl_get_repository (NamespaceImpl* self);
static GIRepository* namespace_impl_real_get_repository (NamespaceImpl* self);
gchar* namespace_impl_get_namespace (NamespaceImpl* self);
static gchar* namespace_impl_real_get_namespace (NamespaceImpl* self);
void namespace_impl_accept (NamespaceImpl* self, GirVisitor* visitor);
static void namespace_impl_real_accept (NamespaceImpl* self, GirVisitor* visitor);
BaseInfoImpl* base_info_impl_new (GIBaseInfo* base_info);
BaseInfoImpl* base_info_impl_construct (GType object_type, GIBaseInfo* base_info);
GType base_info_impl_get_type (void) G_GNUC_CONST;
void base_info_impl_accept (BaseInfoImpl* self, GirVisitor* visitor);
static void namespace_impl_finalize (GObject* obj);
BaseInfo* base_info_new (GIBaseInfo* base_info);
#define BASE_INFO_IMPL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_BASE_INFO_IMPL, BaseInfoImplPrivate))
enum  {
	BASE_INFO_IMPL_DUMMY_PROPERTY
};
GIBaseInfo* base_info_impl_get_base_info (BaseInfoImpl* self);
static GIBaseInfo* base_info_impl_real_get_base_info (BaseInfoImpl* self);
static void base_info_impl_real_accept (BaseInfoImpl* self, GirVisitor* visitor);
static void base_info_impl_finalize (GObject* obj);


gint test_main (gchar** args, int args_length1) {
	gint result = 0;
	Namespace* namespace_ = NULL;
	GIRepository* _tmp0_ = NULL;
	Namespace* _tmp1_ = NULL;
	GirDebugVisitor* visitor = NULL;
	GirDebugVisitor* _tmp2_ = NULL;
	GirDebugVisitor* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_irepository_get_default ();
	_tmp1_ = namespace_new (_tmp0_, "GLib", &_inner_error_);
	namespace_ = _tmp1_;
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp2_ = gir_debug_visitor_new ();
	visitor = _tmp2_;
	_tmp3_ = visitor;
	gir_visitable_accept ((GirVisitable*) namespace_, (GirVisitor*) _tmp3_);
	result = 0;
	_g_object_unref0 (visitor);
	_g_object_unref0 (namespace_);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return test_main (argv, argc);
}


Test* test_construct (GType object_type) {
	Test * self = NULL;
	self = (Test*) g_object_new (object_type, NULL);
	return self;
}


Test* test_new (void) {
	return test_construct (TYPE_TEST);
}


static void test_class_init (TestClass * klass) {
	test_parent_class = g_type_class_peek_parent (klass);
}


static void test_instance_init (Test * self) {
}


GType test_get_type (void) {
	static volatile gsize test_type_id__volatile = 0;
	if (g_once_init_enter (&test_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TestClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) test_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Test), 0, (GInstanceInitFunc) test_instance_init, NULL };
		GType test_type_id;
		test_type_id = g_type_register_static (G_TYPE_OBJECT, "Test", &g_define_type_info, 0);
		g_once_init_leave (&test_type_id__volatile, test_type_id);
	}
	return test_type_id__volatile;
}


void gir_visitor_visit_namespace (GirVisitor* self, Namespace* e) {
	g_return_if_fail (self != NULL);
	GIR_VISITOR_GET_INTERFACE (self)->visit_namespace (self, e);
}


void gir_visitor_visit_base_info (GirVisitor* self, BaseInfo* e) {
	g_return_if_fail (self != NULL);
	GIR_VISITOR_GET_INTERFACE (self)->visit_base_info (self, e);
}


static void gir_visitor_base_init (GirVisitorIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType gir_visitor_get_type (void) {
	static volatile gsize gir_visitor_type_id__volatile = 0;
	if (g_once_init_enter (&gir_visitor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GirVisitorIface), (GBaseInitFunc) gir_visitor_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType gir_visitor_type_id;
		gir_visitor_type_id = g_type_register_static (G_TYPE_INTERFACE, "GirVisitor", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (gir_visitor_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&gir_visitor_type_id__volatile, gir_visitor_type_id);
	}
	return gir_visitor_type_id__volatile;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void gir_debug_visitor_real_visit_namespace (GirDebugVisitor* self, Namespace* e) {
	Namespace* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = namespace_get_namespace (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = string_to_string (_tmp2_);
	_tmp4_ = g_strconcat ("//Visiting ", _tmp3_, "\n", NULL);
	_tmp5_ = _tmp4_;
	g_print ("%s", _tmp5_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp2_);
}


void gir_debug_visitor_visit_namespace (GirDebugVisitor* self, Namespace* e) {
	g_return_if_fail (self != NULL);
	GIR_DEBUG_VISITOR_GET_CLASS (self)->visit_namespace (self, e);
}


static void gir_debug_visitor_real_visit_base_info (GirDebugVisitor* self, BaseInfo* e) {
	BaseInfo* _tmp0_ = NULL;
	GIBaseInfo* _tmp1_ = NULL;
	GIBaseInfo* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	GIAttributeIter iterator = {0};
	GIAttributeIter _tmp8_ = {0};
	gchar* attribute = NULL;
	gchar* value = NULL;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = base_info_get_base_info (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_base_info_get_name (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = string_to_string (_tmp4_);
	_tmp6_ = g_strconcat ("//  Visiting ", _tmp5_, "\n", NULL);
	_tmp7_ = _tmp6_;
	g_print ("%s", _tmp7_);
	_g_free0 (_tmp7_);
	_g_base_info_unref0 (_tmp2_);
	iterator = _tmp8_;
	while (TRUE) {
		BaseInfo* _tmp9_ = NULL;
		GIBaseInfo* _tmp10_ = NULL;
		GIBaseInfo* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		gboolean _tmp14_ = FALSE;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gboolean _tmp17_ = FALSE;
		const gchar* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_ = NULL;
		_tmp9_ = e;
		_tmp10_ = base_info_get_base_info (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp14_ = g_base_info_iterate_attributes (_tmp11_, &iterator, &_tmp12_, &_tmp13_);
		_g_free0 (attribute);
		_tmp15_ = g_strdup (_tmp12_);
		attribute = _tmp15_;
		_g_free0 (value);
		_tmp16_ = g_strdup (_tmp13_);
		value = _tmp16_;
		_tmp17_ = !_tmp14_;
		_g_base_info_unref0 (_tmp11_);
		if (_tmp17_) {
			break;
		}
		_tmp18_ = attribute;
		_tmp19_ = string_to_string (_tmp18_);
		_tmp20_ = value;
		_tmp21_ = string_to_string (_tmp20_);
		_tmp22_ = g_strconcat ("//    ", _tmp19_, " = ", _tmp21_, "\n", NULL);
		_tmp23_ = _tmp22_;
		g_print ("%s", _tmp23_);
		_g_free0 (_tmp23_);
	}
	_g_free0 (value);
	_g_free0 (attribute);
}


void gir_debug_visitor_visit_base_info (GirDebugVisitor* self, BaseInfo* e) {
	g_return_if_fail (self != NULL);
	GIR_DEBUG_VISITOR_GET_CLASS (self)->visit_base_info (self, e);
}


GirDebugVisitor* gir_debug_visitor_construct (GType object_type) {
	GirDebugVisitor * self = NULL;
	self = (GirDebugVisitor*) g_object_new (object_type, NULL);
	return self;
}


GirDebugVisitor* gir_debug_visitor_new (void) {
	return gir_debug_visitor_construct (TYPE_GIR_DEBUG_VISITOR);
}


static void gir_debug_visitor_class_init (GirDebugVisitorClass * klass) {
	gir_debug_visitor_parent_class = g_type_class_peek_parent (klass);
	GIR_DEBUG_VISITOR_CLASS (klass)->visit_namespace = gir_debug_visitor_real_visit_namespace;
	GIR_DEBUG_VISITOR_CLASS (klass)->visit_base_info = gir_debug_visitor_real_visit_base_info;
}


static void gir_debug_visitor_gir_visitor_interface_init (GirVisitorIface * iface) {
	gir_debug_visitor_gir_visitor_parent_iface = g_type_interface_peek_parent (iface);
	iface->visit_namespace = (void (*)(GirVisitor*, Namespace*)) gir_debug_visitor_visit_namespace;
	iface->visit_base_info = (void (*)(GirVisitor*, BaseInfo*)) gir_debug_visitor_visit_base_info;
}


static void gir_debug_visitor_instance_init (GirDebugVisitor * self) {
}


GType gir_debug_visitor_get_type (void) {
	static volatile gsize gir_debug_visitor_type_id__volatile = 0;
	if (g_once_init_enter (&gir_debug_visitor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GirDebugVisitorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gir_debug_visitor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GirDebugVisitor), 0, (GInstanceInitFunc) gir_debug_visitor_instance_init, NULL };
		static const GInterfaceInfo gir_visitor_info = { (GInterfaceInitFunc) gir_debug_visitor_gir_visitor_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gir_debug_visitor_type_id;
		gir_debug_visitor_type_id = g_type_register_static (G_TYPE_OBJECT, "GirDebugVisitor", &g_define_type_info, 0);
		g_type_add_interface_static (gir_debug_visitor_type_id, TYPE_GIR_VISITOR, &gir_visitor_info);
		g_once_init_leave (&gir_debug_visitor_type_id__volatile, gir_debug_visitor_type_id);
	}
	return gir_debug_visitor_type_id__volatile;
}


void gir_visitable_accept (GirVisitable* self, GirVisitor* visitor) {
	g_return_if_fail (self != NULL);
	GIR_VISITABLE_GET_INTERFACE (self)->accept (self, visitor);
}


static void gir_visitable_base_init (GirVisitableIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType gir_visitable_get_type (void) {
	static volatile gsize gir_visitable_type_id__volatile = 0;
	if (g_once_init_enter (&gir_visitable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GirVisitableIface), (GBaseInitFunc) gir_visitable_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType gir_visitable_type_id;
		gir_visitable_type_id = g_type_register_static (G_TYPE_INTERFACE, "GirVisitable", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (gir_visitable_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&gir_visitable_type_id__volatile, gir_visitable_type_id);
	}
	return gir_visitable_type_id__volatile;
}


GIRepository* namespace_get_repository (Namespace* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return NAMESPACE_GET_INTERFACE (self)->get_repository (self);
}


gchar* namespace_get_namespace (Namespace* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return NAMESPACE_GET_INTERFACE (self)->get_namespace (self);
}


Namespace* namespace_new (GIRepository* repository, const gchar* namespace, GError** error) {
	Namespace* result = NULL;
	NamespaceImpl* _tmp0_ = NULL;
	GIRepository* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	NamespaceImpl* _tmp3_ = NULL;
	NamespaceImpl* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (repository != NULL, NULL);
	g_return_val_if_fail (namespace != NULL, NULL);
	_tmp1_ = repository;
	_tmp2_ = namespace;
	_tmp3_ = namespace_impl_new (_tmp1_, _tmp2_, &_inner_error_);
	_tmp0_ = _tmp3_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	}
	_tmp4_ = _tmp0_;
	_tmp0_ = NULL;
	result = (Namespace*) _tmp4_;
	_g_object_unref0 (_tmp0_);
	return result;
}


static void namespace_base_init (NamespaceIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType namespace_get_type (void) {
	static volatile gsize namespace_type_id__volatile = 0;
	if (g_once_init_enter (&namespace_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NamespaceIface), (GBaseInitFunc) namespace_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType namespace_type_id;
		namespace_type_id = g_type_register_static (G_TYPE_INTERFACE, "Namespace", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (namespace_type_id, TYPE_GIR_VISITABLE);
		g_once_init_leave (&namespace_type_id__volatile, namespace_type_id);
	}
	return namespace_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GIRepository* namespace_impl_real_get_repository (NamespaceImpl* self) {
	GIRepository* result = NULL;
	GIRepository* _tmp0_ = NULL;
	GIRepository* _tmp1_ = NULL;
	_tmp0_ = self->priv->_repository;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


GIRepository* namespace_impl_get_repository (NamespaceImpl* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return NAMESPACE_IMPL_GET_CLASS (self)->get_repository (self);
}


static gchar* namespace_impl_real_get_namespace (NamespaceImpl* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	_tmp0_ = self->priv->_namespace;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


gchar* namespace_impl_get_namespace (NamespaceImpl* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return NAMESPACE_IMPL_GET_CLASS (self)->get_namespace (self);
}


NamespaceImpl* namespace_impl_construct (GType object_type, GIRepository* repository, const gchar* namespace, GError** error) {
	NamespaceImpl * self = NULL;
	GIRepository* _tmp0_ = NULL;
	GIRepository* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GIRepository* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (repository != NULL, NULL);
	g_return_val_if_fail (namespace != NULL, NULL);
	self = (NamespaceImpl*) g_object_new (object_type, NULL);
	_tmp0_ = repository;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_repository);
	self->priv->_repository = _tmp1_;
	_tmp2_ = namespace;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->_namespace);
	self->priv->_namespace = _tmp3_;
	_tmp4_ = self->priv->_repository;
	_tmp5_ = self->priv->_namespace;
	g_irepository_require (_tmp4_, _tmp5_, NULL, 0, &_inner_error_);
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	return self;
}


NamespaceImpl* namespace_impl_new (GIRepository* repository, const gchar* namespace, GError** error) {
	return namespace_impl_construct (TYPE_NAMESPACE_IMPL, repository, namespace, error);
}


static void namespace_impl_real_accept (NamespaceImpl* self, GirVisitor* visitor) {
	GirVisitor* _tmp0_ = NULL;
	g_return_if_fail (visitor != NULL);
	_tmp0_ = visitor;
	gir_visitor_visit_namespace (_tmp0_, (Namespace*) self);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_ = 0;
				GIRepository* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				gint _tmp6_ = 0;
				GIRepository* _tmp7_ = NULL;
				const gchar* _tmp8_ = NULL;
				gint _tmp9_ = 0;
				GIBaseInfo* _tmp10_ = NULL;
				GIBaseInfo* _tmp11_ = NULL;
				BaseInfoImpl* _tmp12_ = NULL;
				BaseInfoImpl* _tmp13_ = NULL;
				GirVisitor* _tmp14_ = NULL;
				if (!_tmp1_) {
					gint _tmp2_ = 0;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = self->priv->_repository;
				_tmp5_ = self->priv->_namespace;
				_tmp6_ = g_irepository_get_n_infos (_tmp4_, _tmp5_);
				if (!(_tmp3_ < _tmp6_)) {
					break;
				}
				_tmp7_ = self->priv->_repository;
				_tmp8_ = self->priv->_namespace;
				_tmp9_ = i;
				_tmp10_ = g_irepository_get_info (_tmp7_, _tmp8_, _tmp9_);
				_tmp11_ = _tmp10_;
				_tmp12_ = base_info_impl_new (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = visitor;
				base_info_impl_accept (_tmp13_, _tmp14_);
				_g_object_unref0 (_tmp13_);
				_g_base_info_unref0 (_tmp11_);
			}
		}
	}
}


void namespace_impl_accept (NamespaceImpl* self, GirVisitor* visitor) {
	g_return_if_fail (self != NULL);
	NAMESPACE_IMPL_GET_CLASS (self)->accept (self, visitor);
}


static void namespace_impl_class_init (NamespaceImplClass * klass) {
	namespace_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (NamespaceImplPrivate));
	NAMESPACE_IMPL_CLASS (klass)->get_repository = namespace_impl_real_get_repository;
	NAMESPACE_IMPL_CLASS (klass)->get_namespace = namespace_impl_real_get_namespace;
	NAMESPACE_IMPL_CLASS (klass)->accept = namespace_impl_real_accept;
	G_OBJECT_CLASS (klass)->finalize = namespace_impl_finalize;
}


static void namespace_impl_gir_visitable_interface_init (GirVisitableIface * iface) {
	namespace_impl_gir_visitable_parent_iface = g_type_interface_peek_parent (iface);
	iface->accept = (void (*)(GirVisitable*, GirVisitor*)) namespace_impl_accept;
}


static void namespace_impl_namespace_interface_init (NamespaceIface * iface) {
	namespace_impl_namespace_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_repository = (GIRepository* (*)(Namespace*)) namespace_impl_get_repository;
	iface->get_namespace = (gchar* (*)(Namespace*)) namespace_impl_get_namespace;
}


static void namespace_impl_instance_init (NamespaceImpl * self) {
	self->priv = NAMESPACE_IMPL_GET_PRIVATE (self);
}


static void namespace_impl_finalize (GObject* obj) {
	NamespaceImpl * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_NAMESPACE_IMPL, NamespaceImpl);
	_g_object_unref0 (self->priv->_repository);
	_g_free0 (self->priv->_namespace);
	G_OBJECT_CLASS (namespace_impl_parent_class)->finalize (obj);
}


GType namespace_impl_get_type (void) {
	static volatile gsize namespace_impl_type_id__volatile = 0;
	if (g_once_init_enter (&namespace_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (NamespaceImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) namespace_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (NamespaceImpl), 0, (GInstanceInitFunc) namespace_impl_instance_init, NULL };
		static const GInterfaceInfo gir_visitable_info = { (GInterfaceInitFunc) namespace_impl_gir_visitable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo namespace_info = { (GInterfaceInitFunc) namespace_impl_namespace_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType namespace_impl_type_id;
		namespace_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "NamespaceImpl", &g_define_type_info, 0);
		g_type_add_interface_static (namespace_impl_type_id, TYPE_GIR_VISITABLE, &gir_visitable_info);
		g_type_add_interface_static (namespace_impl_type_id, TYPE_NAMESPACE, &namespace_info);
		g_once_init_leave (&namespace_impl_type_id__volatile, namespace_impl_type_id);
	}
	return namespace_impl_type_id__volatile;
}


GIBaseInfo* base_info_get_base_info (BaseInfo* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return BASE_INFO_GET_INTERFACE (self)->get_base_info (self);
}


BaseInfo* base_info_new (GIBaseInfo* base_info) {
	BaseInfo* result = NULL;
	GIBaseInfo* _tmp0_ = NULL;
	BaseInfoImpl* _tmp1_ = NULL;
	g_return_val_if_fail (base_info != NULL, NULL);
	_tmp0_ = base_info;
	_tmp1_ = base_info_impl_new (_tmp0_);
	result = (BaseInfo*) _tmp1_;
	return result;
}


static void base_info_base_init (BaseInfoIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType base_info_get_type (void) {
	static volatile gsize base_info_type_id__volatile = 0;
	if (g_once_init_enter (&base_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BaseInfoIface), (GBaseInitFunc) base_info_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType base_info_type_id;
		base_info_type_id = g_type_register_static (G_TYPE_INTERFACE, "BaseInfo", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (base_info_type_id, TYPE_GIR_VISITABLE);
		g_once_init_leave (&base_info_type_id__volatile, base_info_type_id);
	}
	return base_info_type_id__volatile;
}


static gpointer _g_base_info_ref0 (gpointer self) {
	return self ? g_base_info_ref (self) : NULL;
}


static GIBaseInfo* base_info_impl_real_get_base_info (BaseInfoImpl* self) {
	GIBaseInfo* result = NULL;
	GIBaseInfo* _tmp0_ = NULL;
	GIBaseInfo* _tmp1_ = NULL;
	_tmp0_ = self->priv->_base_info;
	_tmp1_ = _g_base_info_ref0 (_tmp0_);
	result = _tmp1_;
	return result;
}


GIBaseInfo* base_info_impl_get_base_info (BaseInfoImpl* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return BASE_INFO_IMPL_GET_CLASS (self)->get_base_info (self);
}


static void base_info_impl_real_accept (BaseInfoImpl* self, GirVisitor* visitor) {
	GirVisitor* _tmp0_ = NULL;
	g_return_if_fail (visitor != NULL);
	_tmp0_ = visitor;
	gir_visitor_visit_base_info (_tmp0_, (BaseInfo*) self);
}


void base_info_impl_accept (BaseInfoImpl* self, GirVisitor* visitor) {
	g_return_if_fail (self != NULL);
	BASE_INFO_IMPL_GET_CLASS (self)->accept (self, visitor);
}


BaseInfoImpl* base_info_impl_construct (GType object_type, GIBaseInfo* base_info) {
	BaseInfoImpl * self = NULL;
	GIBaseInfo* _tmp0_ = NULL;
	GIBaseInfo* _tmp1_ = NULL;
	g_return_val_if_fail (base_info != NULL, NULL);
	self = (BaseInfoImpl*) g_object_new (object_type, NULL);
	_tmp0_ = base_info;
	_tmp1_ = _g_base_info_ref0 (_tmp0_);
	_g_base_info_unref0 (self->priv->_base_info);
	self->priv->_base_info = _tmp1_;
	return self;
}


BaseInfoImpl* base_info_impl_new (GIBaseInfo* base_info) {
	return base_info_impl_construct (TYPE_BASE_INFO_IMPL, base_info);
}


static void base_info_impl_class_init (BaseInfoImplClass * klass) {
	base_info_impl_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BaseInfoImplPrivate));
	BASE_INFO_IMPL_CLASS (klass)->get_base_info = base_info_impl_real_get_base_info;
	BASE_INFO_IMPL_CLASS (klass)->accept = base_info_impl_real_accept;
	G_OBJECT_CLASS (klass)->finalize = base_info_impl_finalize;
}


static void base_info_impl_gir_visitable_interface_init (GirVisitableIface * iface) {
	base_info_impl_gir_visitable_parent_iface = g_type_interface_peek_parent (iface);
	iface->accept = (void (*)(GirVisitable*, GirVisitor*)) base_info_impl_accept;
}


static void base_info_impl_base_info_interface_init (BaseInfoIface * iface) {
	base_info_impl_base_info_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_base_info = (GIBaseInfo* (*)(BaseInfo*)) base_info_impl_get_base_info;
}


static void base_info_impl_instance_init (BaseInfoImpl * self) {
	self->priv = BASE_INFO_IMPL_GET_PRIVATE (self);
}


static void base_info_impl_finalize (GObject* obj) {
	BaseInfoImpl * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BASE_INFO_IMPL, BaseInfoImpl);
	_g_base_info_unref0 (self->priv->_base_info);
	G_OBJECT_CLASS (base_info_impl_parent_class)->finalize (obj);
}


GType base_info_impl_get_type (void) {
	static volatile gsize base_info_impl_type_id__volatile = 0;
	if (g_once_init_enter (&base_info_impl_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BaseInfoImplClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) base_info_impl_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaseInfoImpl), 0, (GInstanceInitFunc) base_info_impl_instance_init, NULL };
		static const GInterfaceInfo gir_visitable_info = { (GInterfaceInitFunc) base_info_impl_gir_visitable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo base_info_info = { (GInterfaceInitFunc) base_info_impl_base_info_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType base_info_impl_type_id;
		base_info_impl_type_id = g_type_register_static (G_TYPE_OBJECT, "BaseInfoImpl", &g_define_type_info, 0);
		g_type_add_interface_static (base_info_impl_type_id, TYPE_GIR_VISITABLE, &gir_visitable_info);
		g_type_add_interface_static (base_info_impl_type_id, TYPE_BASE_INFO, &base_info_info);
		g_once_init_leave (&base_info_impl_type_id__volatile, base_info_impl_type_id);
	}
	return base_info_impl_type_id__volatile;
}



